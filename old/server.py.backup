"""FastAPI server for REST API and web dashboard."""

from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, Any, Optional
import json
import csv
import io
import asyncio
import threading

from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.responses import HTMLResponse, StreamingResponse
from fastapi.staticfiles import StaticFiles

from monitor.collectors.gpu import GPUCollector
from monitor.collectors.system import SystemCollector
from monitor.storage.sqlite import MetricsStorage
from monitor.alerting.rules import AlertEngine
from monitor.benchmark.gpu_bench import GPUBenchmark, BenchmarkConfig, get_benchmark_instance


def create_app(config: Dict[str, Any]) -> FastAPI:
    
































































































































































































































            color:            font-size: 1.5em;         
        header h1 {         }            align-items: center;            justify-content: space-between;            display: flex;            margin-bottom: 20px;            border-radius: 12px;            padding: 20px 30px;            background: var(--accent-green);        
        header {        
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }        }            line-height: 1.6;            color: var(--text-primary);            background: var(--bg-primary);            font-family: 'Roboto', sans-serif;        
        body {        
        * { margin: 0; padding: 0; box-sizing: border-box; }        }            --border-color: #4a4a4a;            --accent-red: #dc3545;            --accent-yellow: #ffc107;            --accent-blue: #00a0ff;            --accent-green: #76b900;            --text-secondary: #a0a0a0;            --text-primary: #f0f0f0;            --bg-tertiary: #3a3a3a;            --bg-secondary: #2a2a2a;            --bg-primary: #1a1a1a;        :root {            
        return app        return baseline if baseline else {'status': 'no_baseline'}        baseline = benchmark_instance.get_baseline()    async def get_benchmark_baseline():    
    @app.get("/api/benchmark/baseline")        return benchmark_instance.get_results() if benchmark_instance.results else {'status': 'no_results'}    async def get_benchmark_results():    
    @app.get("/api/benchmark/results")        
        return {'status': 'shutting down'}        timer.start()        timer = threading.Timer(0.5, shutdown)        import threading        
        # Schedule shutdown after response is sent            os.kill(os.getpid(), signal.SIGTERM)        
        def shutdown():        import signal        import os        """Shutdown the server."""    async def shutdown_server():    
    @app.post("/api/shutdown")        }            'message': 'Automatic updates not yet implemented. Please download manually from GitHub releases.'            'status': 'error',        return {        """Install update - placeholder for future implementation."""    async def install_update():    
    @app.post("/api/update/install")            return {'error': str(e)}        except Exception as e:                }                    'error': f'Unable to check for updates: {str(e)}'                    'current': current_version,                    'available': False,                return {            except Exception as e:                        }                            'current': current_version                            'available': False,                        return {                    else:                        }                            'url': data.get('html_url')                            'latest': latest_version,                            'current': current_version,                            'available': True,                        return {                    
                    if latest_version and latest_version > current_version:                    latest_version = data.get('tag_name', '').lstrip('v')                    data = json.loads(response.read().decode())                with urllib.request.urlopen(req, timeout=5) as response:            
            try:            req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0'})            url = "https://api.github.com/repos/your-username/cluster-health-monitor/releases/latest"            
            # Try to fetch latest release from GitHub            current_version = "1.2.0"            import urllib.request        try:        """Check for updates from GitHub releases."""    async def check_for_updates():    
    @app.post("/api/update/check")        return {'status': 'stopping'}        benchmark_instance.stop()    async def stop_benchmark():    
    @app.post("/api/benchmark/stop")        return {'samples': benchmark_instance.get_samples()}    async def get_benchmark_samples():    
    @app.get("/api/benchmark/samples")        return benchmark_instance.get_status()    async def get_benchmark_status():    
    @app.get("/api/benchmark/status")        
        return {'status': 'started', 'message': 'Benchmark started', 'config': bench_config.__dict__}        benchmark_thread.start()        
        benchmark_thread = threading.Thread(target=run_benchmark)            benchmark_instance.start(bench_config)        
        def run_benchmark():            bench_config = BenchmarkConfig.from_mode(mode)        else:            bench_config = BenchmarkConfig.custom(duration, temp_limit, memory_limit, power_limit)        if mode == 'custom':        
        # Create config based on mode            return {'status': 'already_running', 'progress': benchmark_instance.progress}        
        if benchmark_instance.running:        nonlocal benchmark_thread    ):        power_limit: int = 0        memory_limit: int = 0,        temp_limit: int = 85,        duration: int = 30,        mode: str = "standard",    async def start_benchmark(    
    @app.post("/api/benchmark/start")    benchmark_thread = None    benchmark_instance = get_benchmark_instance()    
    # Benchmark endpoints        )            headers={"Content-Disposition": f"attachment; filename=metrics_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"}            media_type="text/csv",            io.BytesIO(output.getvalue().encode()),        
        return StreamingResponse(            writer.writerows(metrics)            writer.writeheader()            writer = csv.DictWriter(output, fieldnames=metrics[0].keys())        if metrics:        
        output = io.StringIO()        metrics = await storage.query(hours=hours)    async def export_csv(hours: int = 24):    
    @app.get("/api/export/csv")        )            headers={"Content-Disposition": f"attachment; filename=metrics_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"}            media_type="application/json",            io.BytesIO(json.dumps(metrics, indent=2).encode()),        return StreamingResponse(        metrics = await storage.query(hours=hours)    async def export_json(hours: int = 24):    
    @app.get("/api/export/json")        }            ]                'cpu_percent', 'memory_percent', 'disk_percent'                'gpu_0_utilization', 'gpu_0_memory_used', 'gpu_0_temperature', 'gpu_0_power',            'metrics': [        return {    async def get_available_metrics():    
    @app.get("/api/history/available")        }            'data': [{'timestamp': m['timestamp'], 'value': m['metric_value']} for m in metrics]            'count': len(metrics),            'hours': hours,            'metric': metric,        return {        metrics = await storage.query(metric_name=metric, hours=hours if hours > 0 else None)        # hours=0 means lifetime (all data)    async def get_history(hours: int = 1, metric: str = "gpu_0_utilization"):    
    @app.get("/api/history")        return {'alerts': alert_engine.get_active_alerts()}    async def get_alerts():    
    @app.get("/api/alerts")        return {'system': collector.collect()}        collector = SystemCollector()    async def get_system():    
    @app.get("/api/system")        return {'processes': collector.collect_processes()}        collector = GPUCollector()    async def get_processes():    
    @app.get("/api/processes")        return {'gpus': collector.collect()}        collector = GPUCollector()    async def get_gpus():    
    @app.get("/api/gpus")        }            'alerts': alerts,            'metrics': metrics,            'status': 'healthy' if not alerts else 'warning',        
        return {        
        alerts = alert_engine.check(metrics)        await storage.store(metrics)        
        # Store metrics for history        }            'system': system,            'gpus': gpus,            'hostname': system.get('hostname', 'unknown'),            'timestamp': datetime.now().isoformat(),        
        metrics = {        system = sys_collector.collect()        
        gpus = gpu_collector.collect()        sys_collector = SystemCollector()        gpu_collector = GPUCollector()    async def get_status():    
    @app.get("/api/status")            return f.read()        with open(template_path, 'r', encoding='utf-8') as f:        template_path = Path(__file__).parent / 'templates' / 'index.html'        # Load HTML from template file    async def dashboard():    
    @app.get("/", response_class=HTMLResponse)        storage.close()    async def shutdown():    
    @app.on_event("shutdown")        await storage.initialize()    async def startup():    
    @app.on_event("startup")    alert_engine = AlertEngine(config.get('alerts', {}))    
    storage = MetricsStorage(config['storage']['path'])    app.mount("/static", StaticFiles(directory=str(static_dir)), name="static")    static_dir = Path(__file__).parent / 'static'    
    # Mount static files    )        version="1.2.0"        description="Real-time GPU cluster monitoring",        title="Cluster Health Monitor",    app = FastAPI(